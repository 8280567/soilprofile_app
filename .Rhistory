1, 2, 3, ggLayer = TRUE)
plotOut
fix(plot_soil)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
fix(plot_soil)
fix(plot_soil)
runApp()
fix(plot_soil)
fix(plot_soil)
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
shiny::runApp()
?soilprofile2::apply_texture
runApp()
runApp()
runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
does_intersect <- function(a, b, c, d, smidgin = 1e-6) {
if(identical(a, b) |
identical(a, c) |
identical(a, d) |
identical(b, c) |
identical(b, d) |
identical(c, d)) {
return(FALSE)
}
x1 <- a[1]
y1 <- a[2]
x2 <- b[1]
y2 <- b[2]
x3 <- c[1]
y3 <- c[2]
x4 <- d[1]
y4 <- d[2]
i <- c(((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) /
((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)),
((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) /
((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)))
ifelse(sum(is.na(i)) <= 0 &
(i[1] > (min(a[1], b[1]) + smidgin) & i[1] < (max(a[1], b[1]) - smidgin)) & (i[1] > (min(a[1], b[1]) + smidgin) & i[1] < (max(a[1], b[1]) - smidgin)) &
(i[2] > (min(a[2], b[2]) + smidgin) & i[2] < (max(a[2], b[2]) - smidgin)) & (i[2] > (min(a[2], b[2]) + smidgin) & i[2] < (max(a[2], b[2]) - smidgin)) &
(i[1] > (min(c[1], d[1]) + smidgin) & i[1] < (max(c[1], d[1]) - smidgin)) & (i[1] > (min(c[1], d[1]) + smidgin) & i[1] < (max(c[1], d[1]) - smidgin)) &
(i[2] > (min(c[2], d[2]) + smidgin) & i[2] < (max(c[2], d[2]) - smidgin)), TRUE, FALSE)
}
rapidly_exploring_random_tree <- function(n = 10000, X = 1000, delta = 2.5) {
# Set up data frames for points and edges
points <- data.frame(x = numeric(n), y = numeric(n))
points[1, ] <- runif(2, 0, X)
edges <- data.frame(x = numeric(n), y = numeric(n), xend = numeric(n), yend = numeric(n))
edges[1, ] <- c(as.numeric(points[1, ]), as.numeric(points[1, ]))
# Main loop
i <- 2
while(i <= n) {
valid <- FALSE
while(!valid) {
# Sample a random point
rp <- runif(2, 0, X)
# Find the nearest neighbour to rp
temp <- points[1:(i-1), ] %>%
mutate(dist = sqrt((rp[1] - x)^2 + (rp[2] - y)^2)) %>%
arrange(dist)
np <- as.numeric(temp[1, c("x", "y")])
# Limit the maximum edge length
if(temp$dist[1] > delta) {
rp2 <- np + (rp - np) / temp$dist[1] * delta
rp <- rp2
}
# Check if the line segment between rp and np intersects an existing edge
temp2 <- edges[1:(i-1), ] %>%
mutate(intersects = does_intersect(rp, np, c(x, y), c(xend, yend)))
if(sum(temp2$intersects) <= 0) {
points[i, ] <- rp
edges[i, ] <- c(np, rp)
valid <- TRUE
}
}
i <- i + 1
print(paste0("Iteration: ", i, " of ", n))
}
edges
}
#Generate rrt edges
set.seed(1)
df <- rapidly_exploring_random_tree() %>% mutate(id = 1:nrow(.))
# Create plot
p <- ggplot() +
geom_segment(aes(x, y, xend = xend, yend = yend, size = -id, alpha = -id), df, lineend = "round") +
coord_equal() +
scale_size_continuous(range = c(0.1, 0.75)) +
scale_alpha_continuous(range = c(0.1, 1)) #+
p
# Create plot
p <- ggplot() +
geom_segment(aes(x, y, xend = xend, yend = yend, size = -id, alpha = -id), df, lineend = "round") +
coord_equal() +
scale_size_continuous(range = c(0.1, 0.75)) +
scale_alpha_continuous(range = c(0.1, 1)) #+
p
remove.packages("soilprofile2", lib="~/Dokumente/Uni_Master/Masterarbeit/App/soilprofile/packrat/lib/x86_64-pc-linux-gnu/3.4.4")
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
runApp()
runApp()
runApp()
runApp()
fix(skeleton)
remove.packages("soilprofile2", lib="~/Dokumente/Uni_Master/Masterarbeit/App/soilprofile/packrat/lib/x86_64-pc-linux-gnu/3.4.4")
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
fix(soilprofile2::skeleton)
fix(skeleton)
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
library(soilprofile2)
library(soilprofile2)
fix(skeleton)
shiny::runApp()
runApp()
fix(apply_texture)
runApp()
soilprofile2::convex_poly
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
shiny::runApp()
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
shiny::runApp()
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
shiny::runApp()
runApp()
runApp()
View(erg)
shiny::runApp()
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
shiny::runApp()
View(erg)
soilprofile2::skeleton
class(erg)
st_as_sf(erg)
View(erg)
unlist(erg)
class(erg)
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
runApp()
fix(skeleton)
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
does_intersect <- function(a, b, c, d, smidgin = 1e-6) {
if(identical(a, b) |
identical(a, c) |
identical(a, d) |
identical(b, c) |
identical(b, d) |
identical(c, d)) {
return(FALSE)
}
x1 <- a[1]
y1 <- a[2]
x2 <- b[1]
y2 <- b[2]
x3 <- c[1]
y3 <- c[2]
x4 <- d[1]
y4 <- d[2]
i <- c(((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) /
((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)),
((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) /
((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)))
ifelse(sum(is.na(i)) <= 0 &
(i[1] > (min(a[1], b[1]) + smidgin) & i[1] < (max(a[1], b[1]) - smidgin)) & (i[1] > (min(a[1], b[1]) + smidgin) & i[1] < (max(a[1], b[1]) - smidgin)) &
(i[2] > (min(a[2], b[2]) + smidgin) & i[2] < (max(a[2], b[2]) - smidgin)) & (i[2] > (min(a[2], b[2]) + smidgin) & i[2] < (max(a[2], b[2]) - smidgin)) &
(i[1] > (min(c[1], d[1]) + smidgin) & i[1] < (max(c[1], d[1]) - smidgin)) & (i[1] > (min(c[1], d[1]) + smidgin) & i[1] < (max(c[1], d[1]) - smidgin)) &
(i[2] > (min(c[2], d[2]) + smidgin) & i[2] < (max(c[2], d[2]) - smidgin)), TRUE, FALSE)
}
identical(a, b)
does_intersect <- function(a, b, c, d, smidgin = 1e-6) {
if(identical(a, b) |
identical(a, c) |
identical(a, d) |
identical(b, c) |
identical(b, d) |
identical(c, d)) {
return(FALSE)
}
x1 <- a[1]
y1 <- a[2]
x2 <- b[1]
y2 <- b[2]
x3 <- c[1]
y3 <- c[2]
x4 <- d[1]
y4 <- d[2]
i <- c(((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) /
((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)),
((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) /
((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)))
ifelse(sum(is.na(i)) <= 0 &
(i[1] > (min(a[1], b[1]) + smidgin) & i[1] < (max(a[1], b[1]) - smidgin)) & (i[1] > (min(a[1], b[1]) + smidgin) & i[1] < (max(a[1], b[1]) - smidgin)) &
(i[2] > (min(a[2], b[2]) + smidgin) & i[2] < (max(a[2], b[2]) - smidgin)) & (i[2] > (min(a[2], b[2]) + smidgin) & i[2] < (max(a[2], b[2]) - smidgin)) &
(i[1] > (min(c[1], d[1]) + smidgin) & i[1] < (max(c[1], d[1]) - smidgin)) & (i[1] > (min(c[1], d[1]) + smidgin) & i[1] < (max(c[1], d[1]) - smidgin)) &
(i[2] > (min(c[2], d[2]) + smidgin) & i[2] < (max(c[2], d[2]) - smidgin)), TRUE, FALSE)
}
rapidly_exploring_random_tree <- function(n = 10000, X = 1000, delta = 2.5) {
# Set up data frames for points and edges
points <- data.frame(x = numeric(n), y = numeric(n))
points[1, ] <- runif(2, 0, X)
edges <- data.frame(x = numeric(n), y = numeric(n), xend = numeric(n), yend = numeric(n))
edges[1, ] <- c(as.numeric(points[1, ]), as.numeric(points[1, ]))
# Main loop
i <- 2
while(i <= n) {
valid <- FALSE
while(!valid) {
# Sample a random point
rp <- runif(2, 0, X)
# Find the nearest neighbour to rp
temp <- points[1:(i-1), ] %>%
mutate(dist = sqrt((rp[1] - x)^2 + (rp[2] - y)^2)) %>%
arrange(dist)
np <- as.numeric(temp[1, c("x", "y")])
# Limit the maximum edge length
if(temp$dist[1] > delta) {
rp2 <- np + (rp - np) / temp$dist[1] * delta
rp <- rp2
}
# Check if the line segment between rp and np intersects an existing edge
temp2 <- edges[1:(i-1), ] %>%
mutate(intersects = does_intersect(rp, np, c(x, y), c(xend, yend)))
if(sum(temp2$intersects) <= 0) {
points[i, ] <- rp
edges[i, ] <- c(np, rp)
valid <- TRUE
}
}
i <- i + 1
print(paste0("Iteration: ", i, " of ", n))
}
edges
}
#Generate rrt edges
set.seed(1)
df <- rapidly_exploring_random_tree() %>% mutate(id = 1:nrow(.))
# Create plot
p <- ggplot() +
geom_segment(aes(x, y, xend = xend, yend = yend, size = -id, alpha = -id), df, lineend = "round") +
coord_equal() +
scale_size_continuous(range = c(0.1, 0.75)) +
scale_alpha_continuous(range = c(0.1, 1)) #+
p
df
test <- root(smooth = F)
?gsubfn
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?convex_poly()
fix(convex_poly)
runApp()
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog"),
verbatimTextOutput("dataInfo")
),
server = function(input, output) {
# reactiveValues object for storing current data set.
vals <- reactiveValues(data = NULL)
# Return the UI for a modal dialog with data selection input. If 'failed' is
# TRUE, then display a message that the previous value was invalid.
dataModal <- function(failed = FALSE) {
modalDialog(
textInput("dataset", "Choose data set",
placeholder = 'Try "mtcars" or "abc"'
),
span('(Try the name of a valid data object like "mtcars", ',
'then a name of a non-existent object like "abc")'),
if (failed)
div(tags$b("Invalid name of data object", style = "color: red;")),
footer = tagList(
modalButton("Cancel"),
actionButton("ok", "OK")
)
)
}
# Show modal when button is clicked.
observeEvent(input$show, {
showModal(dataModal())
})
# When OK button is pressed, attempt to load the data set. If successful,
# remove the modal. If not show another modal, but this time with a failure
# message.
observeEvent(input$ok, {
# Check that data object exists and is data frame.
if (!is.null(input$dataset) && nzchar(input$dataset) &&
exists(input$dataset) && is.data.frame(get(input$dataset))) {
vals$data <- get(input$dataset)
removeModal()
} else {
showModal(dataModal(failed = TRUE))
}
})
# Display information about selected data
output$dataInfo <- renderPrint({
if (is.null(vals$data))
"No data selected"
else
summary(vals$data)
})
}
)
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog"),
verbatimTextOutput("dataInfo")
),
server = function(input, output) {
# reactiveValues object for storing current data set.
vals <- reactiveValues(data = NULL)
# Return the UI for a modal dialog with data selection input. If 'failed' is
# TRUE, then display a message that the previous value was invalid.
dataModal <- function(failed = FALSE) {
modalDialog(
textInput("dataset", "Choose data set",
placeholder = 'Try "mtcars" or "abc"'
),
span('(Try the name of a valid data object like "mtcars", ',
'then a name of a non-existent object like "abc")'),
if (failed)
div(tags$b("Invalid name of data object", style = "color: red;")),
footer = tagList(
modalButton("Cancel"),
actionButton("ok", "OK")
)
)
}
# Show modal when button is clicked.
observeEvent(input$show, {
showModal(dataModal())
})
# When OK button is pressed, attempt to load the data set. If successful,
# remove the modal. If not show another modal, but this time with a failure
# message.
observeEvent(input$ok, {
# Check that data object exists and is data frame.
if (!is.null(input$dataset) && nzchar(input$dataset) &&
exists(input$dataset) && is.data.frame(get(input$dataset))) {
vals$data <- get(input$dataset)
removeModal()
} else {
showModal(dataModal(failed = TRUE))
}
})
# Display information about selected data
output$dataInfo <- renderPrint({
if (is.null(vals$data))
"No data selected"
else
summary(vals$data)
})
}
)
library(shiny)
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog"),
verbatimTextOutput("dataInfo")
),
server = function(input, output) {
# reactiveValues object for storing current data set.
vals <- reactiveValues(data = NULL)
# Return the UI for a modal dialog with data selection input. If 'failed' is
# TRUE, then display a message that the previous value was invalid.
dataModal <- function(failed = FALSE) {
modalDialog(
textInput("dataset", "Choose data set",
placeholder = 'Try "mtcars" or "abc"'
),
span('(Try the name of a valid data object like "mtcars", ',
'then a name of a non-existent object like "abc")'),
if (failed)
div(tags$b("Invalid name of data object", style = "color: red;")),
footer = tagList(
modalButton("Cancel"),
actionButton("ok", "OK")
)
)
}
# Show modal when button is clicked.
observeEvent(input$show, {
showModal(dataModal())
})
# When OK button is pressed, attempt to load the data set. If successful,
# remove the modal. If not show another modal, but this time with a failure
# message.
observeEvent(input$ok, {
# Check that data object exists and is data frame.
if (!is.null(input$dataset) && nzchar(input$dataset) &&
exists(input$dataset) && is.data.frame(get(input$dataset))) {
vals$data <- get(input$dataset)
removeModal()
} else {
showModal(dataModal(failed = TRUE))
}
})
# Display information about selected data
output$dataInfo <- renderPrint({
if (is.null(vals$data))
"No data selected"
else
summary(vals$data)
})
}
)
library("soilprofile2", lib.loc="~/Dokumente/Uni_Master/Masterarbeit/App/soilprofile/packrat/lib/x86_64-pc-linux-gnu/3.4.4")
remove.packages("soilprofile2", lib="~/Dokumente/Uni_Master/Masterarbeit/App/soilprofile/packrat/lib/x86_64-pc-linux-gnu/3.4.4")
#install.packages("devtools")
devtools::install_github("nardusstricta/soilprofile2")
devtools::install_github("nardusstricta/soilprofile2")
devtools::install_github("nardusstricta/soilprofile2")
install.packages("ggspatial")
devtools::install_github("paleolimbot/ggspatial")
devtools::install_github("nardusstricta/soilprofile2")
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
rlang::last_error()
cord_setting(df_global_example, plot_width = 3)
df_global_example <- soilprofile2::soil_example_sf
cord_setting(df_global_example, plot_width = 3)
df_global_example
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
df_global_example <-  data.frame(name = c("Ah", "Bvh", "BvCv"),
depth = c("0-15", "15-43.4", "43.4-70"),
col = c("7.5YR 2/1","10YR 4/3", "2.5Y 5/3"),
skel_dim = c(".1-.8","1-2", "2-3"),
skel_ab = c(0.2, 0.4, .9),
grain_size = c(3, 2, 1),
grain_sd = c(3, 10, 4)) %>%
data_mod()
cord_setting(df_global_example, plot_width = 3)
runApp()
View(df_global_example)
runApp()
runApp()
runApp()
