dplyr::mutate_(area_size = ~ area_comp * random_part) %>%
dplyr::ungroup()
spoint_poly <- point_2_polygon(sf_point = spoint)
#clip the rockshape with the origen geometry
spoint_clean <-  spoint_poly %>%
sf::st_intersection(shape_mod$geometry)
#smoth the rock geometry
spoint_clean[which(spoint_clean$smooth == T),] <-
smoothr::smooth(spoint_clean[which(spoint_clean$smooth == T),])#,
#method = "ksmooth")
#union the geometrys
poly1 <- spoint_clean %>%
dplyr::select_(~ name, ~ union) %>%
dplyr::filter_(~ union == TRUE) %>%
dplyr::group_by_(~ name) %>%
dplyr::summarise()
poly2 <- spoint_clean %>%
dplyr::filter_(~ union == FALSE) %>%
dplyr::select_(~ name)
erg <- rbind(poly1, poly2) %>%
dplyr::group_by_(~name) %>%
dplyr::summarise(do_union = T) %>%
dplyr::ungroup()
return(erg)
}
spoint <- skeleton(shape_mod = sf_example,
skeleton_mat = skeleton_mat)
point_2_polygon <- function(sf_point){
stopifnot("sf" %in% class(sf_point))
stopifnot("nSides" %in% colnames(sf_point))
stopifnot("area_size" %in% colnames(sf_point))
xy_cord <- sf_point %>%  #Koordinaten f√ºr die Funktion extrahieren:
sf::st_coordinates()
df_attr <- sf_point
sf::st_geometry(df_attr) <- NULL
geom <- do.call(
rbind, lapply(
1:nrow(xy_cord), function(i){
convex_poly(cord = xy_cord[i,], attr_poly = df_attr[i,], poly_id = i)
}
)
)
spoint_poly <- sf::st_sfc(
lapply(
1:max(geom[,3]), function(x) sf::st_linestring(geom[geom[,3] == x, 1:2]) %>%
sf::st_cast("POLYGON")
)
) %>%
sf::st_sf(df_attr, geometry = .) %>%
sf::st_convex_hull() %>%
sf::st_buffer(0.0)
}
#' Helper function to extract X and Y coordinates and create ellipses
#'
#' This function builds polygons with given area and number of sides. The starting point is one of the corner points of the polygon.
#'
#' @param cord A numeric vector with the point coordinates specifying the position of the polygon.
#'
#' @param attr_poly the parameters described in function \link[soilprofile2]{skeleton}
#' @param poly_id an id ...
#' @return a matrix with the x and y coordinates and an id for each polygon
convex_poly <- function(cord, attr_poly, poly_id){
stopifnot("numeric" == class(cord))
if(any(attr_poly$nSides < 3 & attr_poly$nSides > 0)){
warning("Possibly the polygons are outside the buffer area!")
}
#checking if parameters are available for stratified rock
area <- attr_poly$area_size
nSides <- attr_poly$nSides
if("phi" %in% colnames(attr_poly)){
if(attr_poly$phi != 0){
phi <- pi/(pi - attr_poly$phi)
a <- 5  #attr_poly$a
b <- 3  #attr_poly$b
t <- seq(0, 2 * pi, length.out = attr_poly$nSides)
x <- a * cos(t) * cos(phi) - b * sin(t) * sin(phi)
y <- a * cos(t) * cos(phi) + b * sin(t) * cos(phi)
y <- rnorm(y, y, .02)
x <- rnorm(x, x, .2)
points_list1 <- list(x=NULL, y= NULL)
points_list1$x <- x
points_list1$y <- y
nSides <- length(t)
}else{
points_list1 <-  poly_fun(nSides = nSides, area = area)
}
}else{
points_list1 <-  poly_fun(nSides = nSides, area = area)
}
# Find the area of the polygon
m <- matrix(unlist(points_list1), ncol=2)
m <- rbind(m, m[1,])
current_area <- 0.5 * (sum(m[1:nSides, 1] *
m[2:(nSides + 1),2]) -
sum(m[1:nSides, 2] * m[2:(nSides + 1), 1]))
points_list1$x <- points_list1$x * sqrt(area/current_area)
points_list1$y <- points_list1$y * sqrt(area/current_area)
p <- data.frame(x = points_list1$x + cord[1],
y= points_list1$y + cord[2],
name = poly_id)
poo <- rbind(p, p[1,])
return(as.matrix(poo))
}
#' Helper function to calculate a polygon by given number of sides and area.
#'
#' This function builds polygons with given area and number of sides. The starting point is one of the corner points of the polygon.
#' The area (A) of a convex polygon can be found with the following formula
#' \eqn{A = 1/2 * [(x1*y2 + x2*y3 + ... + xn*y1) - (y1*x2 + y2*x3 + ... + yn*x1)]}
#'
#' @param nSides number of sides
#' @param area the area of the polygon
#' @return A list with the x and y coordinates
#' @export
poly_fun <- function(nSides, area){
stopifnot(class(nSides) == "numeric" & class(area) == "numeric")
radius <- sqrt((2 * area) / (nSides * sin((2 * pi) / nSides)))
angle <- (2 * pi) / nSides
# Randomize the radii/angles
radii <- rnorm(nSides, radius, radius/10)
angles <- rnorm(nSides, angle, angle/10) * 1:nSides
angles <- sort(angles)
points <- list(x=NULL, y= NULL)
points$x <- cos(angles) * radii
points$y <- sin(angles) * radii
return(points)
}
spoint <- skeleton(shape_mod = sf_example,
skeleton_mat = skeleton_mat)
#Plot the result:
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
geom_sf(data = spoint) +
soil_theme()
skeleton <- function(shape_mod, skeleton_mat, seed = 34){
stopifnot(c("sf", "data.frame") %in% class(shape_mod)  &
class(skeleton_mat) == "data.frame")
stopifnot(c("name", "skel_ab", "skel_dim_from", "skel_dim_to", "area") %in%
colnames(shape_mod))
stopifnot(c("name","nSides","smooth", "union",
"phi", "strat", "cellnumber", "rotation") %in%
colnames(skeleton_mat))
set.seed(seed)
shape_s  <- shape_mod %>%
#select the default parameter:
dplyr::select_(~ name, ~ skel_ab, ~ skel_dim_from, ~ skel_dim_to, ~ area) %>%
#dplyr::rowwise() %>%
dplyr::right_join(skeleton_mat, by = "name") %>%
dplyr::mutate_(skel_ab = ~ ifelse(strat == FALSE,
skel_ab * 0.41149 + 2.02873 * skel_ab ^ 2 + 0.04067,
skel_ab
)) %>%
#calculate the absolute skeleton content
dplyr::rowwise() %>%
dplyr::mutate_(area_comp = ~ (area * skel_ab)) %>%
#calculate the mean of skeleton dimension
dplyr::mutate_(skel_dim_mean = ~ mean(c(skel_dim_from, skel_dim_to), rm.na = T)) %>%
#calculate the number of skeleton
dplyr::mutate_(skel_number = ~ round((area_comp/(skel_dim_mean * skel_dim_mean))))  %>%
tidyr::replace_na(list(skel_number = 0))  %>%
#join with skeleton parameter:
dplyr::ungroup() %>%
sf::st_sf()
#Calculating the coordinates for the stratified rock
for(i in which(shape_s$strat == T)){
rows <- shape_s$cellnumber[i]
shape_s$geometry[i] <-
basic_regular_point(shape_s$geometry[i],
cellnumber = c(rows, shape_s$skel_number[i]/rows),
rotation = shape_s$rotation[i]) %>%
sf::st_geometry()
}
#Calculating the coordinates for the random rock
for(i in which(shape_s$strat == F)){
shape_s$geometry[i] <- sf::st_sample(shape_s$geometry[i],
shape_s$skel_number[i]) %>%
sf::st_union()
}
#extract the point geometries (the coordinates in which the rock is placed)
spoint <-  sf::st_intersection(shape_s,  shape_mod$geometry) %>%
sf::st_collection_extract(type = "POINT") %>%
sf::st_cast("POINT") %>%
dplyr::group_by_(~name) %>%
#inserting a random parameter of the rock surface
dplyr::mutate_(random_part = ~ runif(n(), min = skel_dim_from, max = skel_dim_to)) %>%
dplyr::mutate_(random_part = ~ random_part/sum(random_part)) %>%
dplyr::mutate_(area_size = ~ area_comp * random_part) %>%
dplyr::ungroup()
spoint_poly <- point_2_polygon(sf_point = spoint)
#clip the rockshape with the origen geometry
spoint_clean <-  spoint_poly %>%
sf::st_intersection(shape_mod$geometry)
#smoth the rock geometry
spoint_clean[which(spoint_clean$smooth == T),] <-
smoothr::smooth(spoint_clean[which(spoint_clean$smooth == T),])#,
#method = "ksmooth")
#union the geometrys
poly1 <- spoint_clean %>%
dplyr::select_(~ name, ~ union) %>%
dplyr::filter_(~ union == TRUE) %>%
dplyr::group_by_(~ name) %>%
dplyr::summarise()
poly2 <- spoint_clean %>%
dplyr::filter_(~ union == FALSE) %>%
dplyr::select_(~ name)
erg <- rbind(poly1, poly2) #%>%
# dplyr::group_by_(~name) %>%
# dplyr::summarise(do_union = F) %>%
# dplyr::ungroup()
return(erg)
}
spoint <- skeleton(shape_mod = sf_example,
skeleton_mat = skeleton_mat)
spoint
runApp()
runApp()
library(shiny)
selectInput
#get the path
photo_Ah_path <- system.file("extdata", "photo_example.png",
package = "soilprofile2")
png_import(photo_Ah_path, sf_example[1,], raster2polygon = F)
library(soilprofile2)
png_import(photo_Ah_path, sf_example[1,], raster2polygon = F)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(processMod)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
#mask an extent the photo tho the first horizont:
photo_Ah <- png_import(photo_Ah_path, sf_example[1,], raster2polygon = F)
#get the path
photo_Ah_path <- system.file("extdata", "photo_example.png",
package = "soilprofile2")
#mask an extent the photo tho the first horizont:
photo_Ah <- png_import(photo_Ah_path, sf_example[1,], raster2polygon = F)
knitr::opts_chunk$set(collapse=TRUE, comment="##", fig.retina=2, fig.path = "README_figs/README-")
knitr::opts_chunk$set(
collapse = TRUE,
message = FALSE,
warning = FALSE,
error = FALSE,
comment = "#>",
fig.path = "README-"
)
#install the development version from github with
#install.packages("devtools")
#devtools::install_github("nardusstricta/soilprofile2")
#load packages:
library(dplyr)
library(soilprofile2)
library(ggplot2)
#create an example dataset and modify the color and depths
df_example <- data.frame(name = c("Ah", "Bvh", "BvCv"),
depth = c("0-15", "15-43.4", "43.4-70"),
col = c("7.5YR 2/1","10YR 4/3", "2.5Y 5/3"),
skel_dim = c(".1-.8","1-2", "2-3"),
skel_ab = c(0.2, 0.4, .9),
clay = c(0, .8, 0),
silt = c(0, .5, .5),
sand = c(0, .2, .5)) %>%
data_mod()
#set coordinates, four points on each horizon
cord_example  <-  cord_setting(df_example, plot_width = 2)
#create a simple feature: each line represents a horizon
#with one polygon as geometry.
sf_example <- sf_polygon(df_geom = cord_example,
df_attri = df_example)
#this data is stored in the package
#as example datan (data("soil_example_sf"))
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
soil_theme()
lattri_example <- data.frame(name= c(1,2,3),
numberX = c(3, 6, 6),
sd = c(.3, .5, 1),
# change it from c(.3, .5, 1) to c(1, 3, 1)
sm = c(TRUE, TRUE, FALSE)
)
line_example <- line_mod(df = cord_example,
line_attri = lattri_example)
example_profile <- split_polygon(polygon = sf_example,
line = line_example)
example_profile %>%
ggplot() +
geom_sf(fill = example_profile$rgb_col) +
soil_theme()
df_smooth <- data.frame(
buffer_size = c(5), #from 5 to 4
buffer_number = c(60),  #from 30 to 300
nSides = c(10), #from 10 to 50
rate = c(.6), # from 12 to 40
#and with shape  from .1 to .6
name = c(3)
)
#Applying the function
smooth_profile <- smooth_trans(lmod = line_example,
shape_mod = example_profile,
attr_df = df_smooth,
smoothness = 3,
shape = 1) #von 12 auf .1
#Plot the result:
smooth_profile %>%
ggplot() +
geom_sf(fill = smooth_profile$rgb_col) +
soil_theme()
skeleton_mat <- data.frame(
name = c(1, 2, 3),
nSides = c(4, 13, 20),
smooth = c(T, T, T),
union = c(T, F, T),
strat = c(F, T, F),
cellnumber = c(0, 18, 0),
rotation = c(0, 20, 0),
phi = c(0, 0, 0)
)
spoint <- skeleton(shape_mod = sf_example,
skeleton_mat = skeleton_mat)
#Plot the result:
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
geom_sf(data = spoint) +
soil_theme()
root_example <- basic_random_line(polygon = smooth_profile[1,],
number = 800,
line_length = .5,
variation = .4,
smoothness = 5)
smooth_profile %>%
ggplot() +
geom_sf(fill = smooth_profile$rgb_col) +
geom_sf(data = spoint) +
geom_sf(data = root_example,
size = root_example$id/max(root_example$id),
col = "orange4") + #specifying the color
soil_theme()
## creation of the patterns
texture_example <- apply_texture(shape = example_profile,
buffer = -1,
background = c(T, T, T)
)
##set dafault aesthetics
texture_par <-  par_default(texture_example)
## plotting data
texture_par %>%
ggplot() +
geom_sf(fill = texture_par$bgc,
col = texture_par$col,
shape = texture_par$pch,
linetype = texture_par$linetype,
size = texture_par$size) +
soil_theme()
#first we need a path to our png file
str_Bvh <- system.file("extdata", "broeckel.png", package = "soilprofile2")
str_BvCv <- system.file("extdata", "prismen.png", package = "soilprofile2")
#Then we put the first structure into the second horizon
#and the second into the third.
str_all <- multiple_png(sf_example[c(2,3), ], c(str_Bvh, str_BvCv))
photo_Ah_path <- system.file("extdata", "photo_example.png",
package = "soilprofile2")
#mask an extent the photo tho the first horizont:
photo_Ah <- png_import(photo_Ah_path, sf_example[1,], raster2polygon = F)
sf_example[1,]
#plot the result:
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
geom_sf(data = str_all, fill = "black") +
ggspatial::layer_spatial(photo_Ah) +
soil_theme()
library(soilprofile2)
library(ggplot2)
#create an example dataset and modify the color and depths
df_example <- data.frame(name = c("Ah", "Bvh", "BvCv"),
depth = c("0-15", "15-43.4", "43.4-70"),
col = c("7.5YR 2/1","10YR 4/3", "2.5Y 5/3"),
skel_dim = c(".1-.8","1-2", "2-3"),
skel_ab = c(0.2, 0.4, .9),
clay = c(0, .8, 0),
silt = c(0, .5, .5),
sand = c(0, .2, .5)) %>%
data_mod()
#set coordinates, four points on each horizon
cord_example  <-  cord_setting(df_example, plot_width = 2)
#create a simple feature: each line represents a horizon
#with one polygon as geometry.
sf_example <- sf_polygon(df_geom = cord_example,
df_attri = df_example)
#this data is stored in the package
#as example datan (data("soil_example_sf"))
#get the path
photo_Ah_path <- system.file("extdata", "photo_example.png",
package = "soilprofile2")
sf_example[1,]
#mask an extent the photo tho the first horizont:
photo_Ah <- png_import(photo_Ah_path, sf_example[1,], raster2polygon = F)
photo_Ah
#plot the result:
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
geom_sf(data = str_all, fill = "black") +
ggspatial::layer_spatial(photo_Ah) +
soil_theme()
#plot the result:
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
#geom_sf(data = str_all, fill = "black") +
ggspatial::layer_spatial(photo_Ah) +
soil_theme()
photo_Ah
layer_spatial(photo_Ah)
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col)
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
#geom_sf(data = str_all, fill = "black") +
ggspatial::layer_spatial(photo_Ah)
library("ggspatial", lib.loc="~/Dokumente/Uni_Master/Masterarbeit/App/soilprofile/packrat/lib/x86_64-pc-linux-gnu/3.4.4")
sf_example %>%
ggplot() +
geom_sf(fill = sf_example$rgb_col) +
#geom_sf(data = str_all, fill = "black") +
ggspatial::layer_spatial(photo_Ah)
raster::plot(photo_Ah)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::req(input[[paste0(label[pvars])]])
runApp()
runApp()
all(c(F, T, F, T)==F)
all(c(F, F, F, F)==F)
runApp()
runApp()
runApp()
library(profvis)
profvis({
runApp(display.mode = "normal")
})
profvis({
runApp(display.mode = "normal")
})
ptions(shiny.reactlog=TRUE)
options(shiny.reactlog=TRUE)
shiny::runApp
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
options(shiny.reactlog=TRUE)
shiny::runApp()
